## 面试题

时间：45mins

##### 1.算法笔试一个小时

​	具体看笔试题

##### 2.解释每一道题的算法思路与时间空间复杂度

​	具体看面试题答案

##### 3.浏览器按下回车经历什么

​	参考连接：https://github.com/Doctor-wu/frontendStudy/blob/master/%E4%B8%93%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/note1.md

​	流程详情：

1. **构建请求**

   输入URL后，主进程中的 UI 线程接受到用户的 URL，判断用户输入的是 query 还是 URL。如果是 URL，把 URL 转发给网络线程，网络线程会构建请求行信息，构建好之后，浏览器就准备发起网络请求

2. **查找强缓存**

   浏览器在发起真正的网络请求前，会**先检查浏览器的强缓存，如果命中，直接返回对应资源文件的副本**。否则进入下一步

3. **Dns解析**

   发送网络请求首先要进行DNS解析，也就是**根据域名找到对应的ip地址**，关于dns解析，大致是先查找本地 DNS 缓存，找不到就问本地 DNS 服务器，再依次问根域 DNS 服务器，一级域名服务器，二级域名服务器，最后把找到的 IP 地址层层传递回来。

4. **建立tcp链接**

   知道服务器的ip地址后，就可以和服务器建立连接，分两种，可靠的TCP（可靠，速度慢）和不可靠的UDP（速度快），**HTTP基于TCP**，所以需要跟服务器建立TCP连接。

   **三次握手的重要性**：是因为**客户端和服务器都要确认双方有正常的收发能力**，两次握手的话，客户端能知道服务器能收发，但服务器只知道客户端能发送数据，并不知道能接收数据。

5. **发送请求，接收响应**

   建立了TCP连接，就可以进行HTTP通信了，请求和响应中的数据就是在这个过程中传输。

   服务器会用过响应行中的**状态码**告诉游览器的处理结果，常见的状态码有以下几类：

   - 2XX：成功，最常见的是 200 OK
   - 3XX：需要进一步操作，比如 301 永久重定向，302 临时重定向，304 未修改
   - 4XX：请求出错，比如最常见的 404 未找到资源，还有 403 禁止请求
   - 5XX：服务器出错，比如 500 服务器内部错误，502 网关错误

6. **查找协商缓存**

   如果上一步中HTTP响应行中的状态码为304（Not Modified）,内容为空，相当于告诉浏览器“**服务器上的资源跟你本地缓存的副本一样，从缓存中拿就行啦**”，相当于命中。这就是协商缓存的流程。**当强缓存过期**，或者 `cache-control` 设置 `no-cache` 时，就会进行协商缓存，浏览器会发送请求到服务器，根据响应头中的状态码判断是否要从缓存中读取。

7. 断开tcp连接

   浏览器接受完服务器返回的资源后，需要断开 TCP 连接。断开 TCP 连接需要经历四次挥手。

   之所以要四次挥手，而不是三次，是因为**多了服务端通知客户端数据发送完毕的第三次挥手**。大家想想，如果没有第三次挥手，而是客户端直接确认关闭连接的第四次挥手，客户端就无法收到服务器还没发完的数据，导致**数据丢失**。

8. 解析HTML，构建DOM树

   完成上面的网络请求过程后，接下来就是浏览器的渲染进程解析和渲染资源的过程了。首先对于 HTML 文件，浏览器由它生成 DOM 树（一种浏览器可以理解的树形结构，全称是 Document Object Model）。

9. **样式计算，构建 CSSOM 树 (Style calculation)**

   样式计算的目的是为了计算出上面 DOM 节点中每个元素的具体样式，这个阶段大体可以分成三步：

   1.  **把 CSS 转化为浏览器能够理解的结构 styleSheets**
   2. **转换样式表中的属性值，使其标准化**
   3.  **计算出 DOM 树中每个节点的具体样式**

   浏览器处理 CSS 的过程，其实**跟 HTML 是很类似的，从字节开始，翻译成字符、序列化、生成节点，最终生成 CSSOM (CSS Object Model)。**

10. **布局 (Layout)**

    我们虽然有 DOM 树和 DOM 树中每个节点的样式，但还不知道这些 DOM 元素的几何位置，所以接下来就需要计算出 DOM 树中可见元素的几何位置。我们把这个计算过程叫做布局。布局阶段可以分成两个子阶段，**创建布局树**和**布局计算**。

    构建完布局树，接下来就是**计算布局树节点的实际坐标**了。至于具体的计算过程非常的复杂，这里不加以记录。

11. 生成图层树

12. 绘制

13. 栅格化

14. 合成与显示

##### 4.http2.0和1的区别，是否同时请求css文件不阻塞页面解析

​	css不会阻塞页面解析，不会阻塞dom树的构建，但会阻塞DOM树渲染。

​		构建DOM树的时候，当遇到JS元素时，HTML解析器就会将控制权转让给JavaScript引擎线程，该线程会阻断HTML解析器的运行，当js加载并且执行完毕后，JavaScript引擎线程会将控制权还给HTML解析器，让其去继续构建dom树；当遇到css元素时，浏览器会开 启一个异步请求线程，在该线程上，浏览器会去请求相应的css文件，并且根据该文件去构建cssDom树(也叫css rule)，该线程会阻塞 JavaScript引擎线程（即css后 面的js模块的解析会在css解析完毕后执行），但是不会阻塞dom树的构建.

##### 5.defer和async的作用

​	使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。
​	使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。

##### 6.http状态码解释1XX2XX成功3XX缓存4XX服务端返回错误5XX服务器内部错误

​	参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

##### 7.强缓存、协商缓存（304命中）

​	参考：https://github.com/xiangxingchen/blog/issues/9

##### 8.通常强缓存，协商缓存应用场景

​	参考：https://github.com/amandakelake/blog/issues/41

##### 9.XSS攻击原理说一下，如何防范

​	参考连接：https://juejin.cn/post/6844904194999074829#heading-5

- XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

- 分类：

  - 反射型

    反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。

  - 存储型

    存储型 XSS 会把用户输入的数据 "存储" 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。

  - 基于dom

    客户端JavaScript可以访问浏览器的DOM文本对象模型是利用的前提，当确认客户端代码中有DOM型XSS漏洞时，并且能诱使(钓鱼)一名用户访问自己构造的URL，就说明可以在受害者的客户端注入恶意脚本。

- 防范：

  - 对输入的参数进行类型，字符集，长度的过滤
  - 增加HTTP安全头字段：X-Content-Type-Options和X-XSS-Protection
    - 增加`X-Content-Type-Options：nosniff`的HTTP安全头字段，可避免部分版本IE浏览器无视`Content-Type`设置执行XSS Payload。
    - 增加`X-XSS-Protection:1;mode=block`的HTTP安全头字段可提示浏览器发现XSS Payload时不要渲染文档
  - 使用内置转义函数
    - 当使用PHP、java、Nodejs的后端服务器接收到内容需要输出到HTML标签内时，都可以使用相对应的转义函数转义，将会对`< > ' " &`等字符转义
  - DOM型XSS防范
    - 查看代码是否有document.write、eval、window之类能造成危害的地方，利用第三方的过滤方法filter.js进行过滤。

##### 10.vue-router讲一下，history模式（html5新增api pushState，需要后端一起配置）、hash模式（#，改变#后面的值）

- 参考：https://juejin.cn/post/6844903612930326541

- 原理：保证只有一个html页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。
- 重点：
  - 改变 url 且不让浏览器像服务器发送请求
  - 改变url能触发响应的事件
- 两种路由模式
  - 哈希路由
    - 由于url的hash改变不会触发请求
    - 会触发hashchange事件
  - history路由模式
    - history 新增了以下几个 API，pushState，replaceState
    - 不会跳转页面。
- 个人习惯用hash模式，history模式需要后端服务器一起配合。

##### 11.一个对象遍历原型链的属性（对象_proto_原型属性，遍历原型链，遍历__proto,每一次找proto的__proto,最后原型==null可以停止）

- 代码:

  ```js
  let proto = obj.__proto__;
  while(proto!=null) {
      console.log(proto);
      proto = proto.__proto__;
  }
  ```

- null之前的\_\_proto\_\_是object

##### 12.是否所有对象原型链上都有object，Object.create解释一下，无object的应用场景和好处（参考连接：https://juejin.cn/post/6844903589815517192）

- 并非所有的对象上原型上都有object

- Object.create(null, {})则能建立一个原型上无object对象

- 通过Object.create(null),我们可以显式指定null作为它的原型。所以它绝对没有属性，

  甚至没有构造函数，toString、hasOwnProperty属性，所以如果需要的话

- 使用场景：

  - 如果需要对象的继承属性和方法，就平常建立即可
  - 如果只需要一个纯净的对象，那就使用 Object.create(null)，比如说，我只需要用对象来保存一些数据，然后进行循环取用，提高循环效率。这个时候如果对象有原型链，那便会在循环的时候去循环它的各个属性和方法，然后这不是必要的，我们只是要他里面的元素而已，效率会降低

- 总结：

  - 你需要一个非常干净且高度可定制的对象当作数据字典的时候；
  - 想节省`hasOwnProperty`带来的一丢丢性能损失并且可以偷懒少些一点代码的时候