# Proxy
+ ### 理解
    在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制
+ ### 代理基础
    + 目标对象既可以直接被操作，也可以通过代理来操作，但直接操作会绕过代理施于的行为。
    + 创建空代理
        + 最简单的代理，什么都不做。
        + 默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。
        + 代理是由Proxy构造函数创建的。两个参数：目标对象和处理程序对象。（不能缺）
        + Proxy不能用不能用instanceof 因为Proxy.prototype是undefined
    + 捕获器(trap)
        + 使用代理的主要目的是可以定义捕获器。
        + 捕获器就是在处理程序对象中定义的“基本操作的拦截器”，每个处理程序对象可以包含0到多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。
        + 每次在代理对象调用这些基本操作时，代理可以在这些操作传播到目标对象之前调用捕获器函数，从而拦截并修改响应行为
        + 只有在代理对象上执行这些操作才会触发捕获器，在目标对象上不受影响。
    + 捕获器参数和反射api
        + 所有捕获器都可以访问到捕获器相应的参数，基于这些参数可以重建被捕获方法的原始行为。
        + 并非所有的捕获器都简单。实际上，调用Reflect(反射)对象的同名方法来轻松重构
        + 反射api让开发者以最少的代码修改捕获的方法。
    + 捕获器不变式（trap invariant）
        + 捕获器几乎可以改变所有基本方法行为，但非没有限制。捕获处理程序行为必须遵循“捕获器不变式”(trap invariant),方法不用而异
        + 例子：如目标函数的值返回了一个不可配置，不可写的属性，那么捕获器不应该返回不同类型的属性.
    + 可撤销代理
        + Proxy暴露了revocable方法，支持耻笑代理对象与目标对象的关联。不可逆的。
    + 实用反射API
        + 反射API和对象API
            + 反射API并不限于捕获处理程序
            + 大多数反射API方法在Object有对应的方法
        + 状态标记
            + 很多反射方法返回成为“状态标记”的布尔值。表示意图是否成功
        + 一等函数替代操作符
            ```js
            Reflect.get() //替代对象属性的访问操作符
            Reflect.set() //替代=
            Reflect.has() //替代in或with
            Reflect.deleteProperty() //替代delete
            Reflect.construct()   //替代new
            ```
        + 安全地应用函数
    + 代理另一个代理
    + 代理地问题和不足
        + this指向问题，如果遇到之前地weakSet存this 很容易出现问题
        + 代理和内部槽位 有些内置类型可能会依赖代理无法控制的机制 如Date
