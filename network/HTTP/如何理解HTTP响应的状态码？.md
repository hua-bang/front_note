## 如何理解HTTP响应的状态码？

#### HTTP状态码分成5类

- 1xx表示继续发送请求
- 2xx表示请求成功
- 3xx表示资源已经找到但还需要继续进行操作
- 4xx表示客户端错误
- 5xx表示服务器错误

## 1xx

1xx表示请求已被接受，但需要后续处理。例如：

#### 100(continue)

客户端应继续请求

#### 101(Switching Protocols)

需要切换协议，服务器通过的`Upgrade`响应头字段通知客户端。

HTML5引入的WebSocket便是这样工作的。首先客户端请求websocket所在的URL，服务器返回101，然后便建立了全双工的TCP连接。 注意`Upgrade`和`Connection`头字段属于Hop-by-hop字段，设置Websocket代理时需要继续设置这两个字段，而不是简单地转发请求。

## 2xx

请求已成功被服务器接受、理解、并接受

#### 200（OK）

请求已经成功，请求所希望响应从这里返回

#### 201(created)

请求已经被实现，而且有一个新的资源已经依据请求的需要而创建。在RESTFul风格的URL设计中，通常用来响应POST请求。

#### 202（Accepted）

服务器成功处理了请求，但不需要返回任何实体内容。

#### 204

响应禁止包含任何消息体。浏览器收到该响应后不应产生文档视图的变化。

#### 205（Reset Content）

服务器成功处理了请求，但不需要返回任何实体内容，205响应禁止包含任何消息体。 与204不同的是，返回此状态码的响应要求请求者重置文档视图。比如用户刚刚提交一个表单，返回205后页面重置，用户可以立即填写下一个表单。

#### 206（Partial Content）

HTTP协议允许分片传输。请求头中包含`Range`字段时，响应需要只返回`Range`指定的那一段。响应中应包含`Content-Range`来指示返回内容的范围。

## 3xx

这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向， 重定向目标在本次响应的`Location`头字段中指明。

### 301（Moved Permanently）

被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果该请求不是GET/HEAD， 浏览器通常会要求用户确认重定向。

301通常用于网站迁移时，服务器对旧的URL进行301重定向到新的URL。这样搜索引擎可以正确地更新原有的页面排名等信息。

### 302（Found）

请求的资源现在临时从不同的URI响应请求。除非指定了`Cache-Control`或`Expires`，否则该响应不可缓存。 如果当前请求非HEAD或GET，浏览器需取得用户确认，再进行重定向。

### 303（See Other）

对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。 这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 303响应禁止被缓存。

### 304（Not Modified）

如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变。 304响应禁止包含消息体。

协商缓存

304响应也是一种缓存机制。Web服务器对静态资源文件通常会采取缓存，因此在Web开发中你可以看到大量的304响应。 服务器给出的相应中通常会包含`Etag`来标识资源ID，比如：

```
ETag: "686897696a7c876b7e"
```

客户端在下次访问同一URL时会设置头字段`If-None-Match`（这是一个请求条件）：

```
If-None-Match: "686897696a7c876b7e"
```

服务器返回资源前会判断`Etag`是否与客户端提供的`If-None-Match`匹配，如果匹配则说明资源未发生改变，此时应返回304.

#### 关于HTTP缓存的讨论

除了使用`ETag/If-None-Match/If-Match`通过文件内容来缓存外，还可以使用`Last-Modified/If-Modified-Since`通过文件修改时间来进行缓存。 这两者都需要客户端再次发送HTTP请求，如果文件未发生改变，服务器返回304。

而另外一种缓存策略`Expires/Cache-Control`则可以让客户端避免再次发送请求。一般会优先使用`Cache-Control`，它能够更加精细地控制缓存策略。

### 其他

- 300（Multiple Choices）
- 305（Use Proxy）
- 307（Temporary Redirect）

## 4xx

这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体。

#### 400(BAD Request)

由于包含语法错误，当前请求无法被服务器理解。400通常在服务器端表单验证失败时返回。

#### 401(unauthorized)

当前请求需要用户验证，响应中会包含一个`WWW-Authenticate`字段来询问用户的授权信息。 而客户端的下次请求需要提供包含`Authorization`头的请求。

#### 403(Forbidden)

服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助。

#### 404(Not Found)

这太常见了。就是请求所希望得到的资源未被在服务器上发现。

当通常用于当服务器不想揭示到底为何请求被拒绝时，比如应当返回500时服务器不愿透露自己的错误。

#### 405（Method Not Allowed）

请求行中指定的请求方法不能被用于请求相应的资源。

在Web开发中通常是因为客户端和服务器的方法不一致，比如客户端通过PUT来修改一个资源，而服务器把它实现为POST方法。 开发中统一规范就好了。

#### 413（Request Entity Too Large）

服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。

### 5XX

这类一般表示服务器在处理请求过程中发生了错误或异常发生。

#### 500（Internal Server Error）

通常是代码出错，后台Bug。一般的Web服务器通常会给出抛出异常的调用堆栈。 然而多数服务器即使在生产环境也会打出调用堆栈，这显然是不安全的。

#### 502（Bad Gateway）

作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

如果你在用HTTP代理来翻墙，或者你配置了nginx来反向代理你的应用，你可能会常常看到它

#### 503（Service Unavailable）