## 深度与广度优先搜索

**重点**：深度优先搜索算法DFS和广度优先搜素算法BFS

DFS 和 BFS 经常在算法面试题当中出现，在整个算法面试知识点中所占的比重非常大。应用最多的地方就是对图进行遍历，树也是图的一种。

### 深度优先搜索（DFS）

从起点出发，从规定的方向中选择其中一个不断地向前走，直到无法继续为止，然后尝试另外一种方向，知道最终走到终点。

DFS解决地是连通性的问题，即，给定两个点，一个是起始点、一个是终点、判断是否有一条路径连接起点和终点。起点和重点、也可以指的是某种起始状态和最终状态。问题的要求并不在乎路径是长还是短，只在乎有还是没有。有时候题目也会要求把找到的路径完整的打印出来。

实现方法的不同，时间和空间复杂度不同

- 归实现：
  - 代码看上去很简洁；
  - 实际应用中，递归需要压入和弹出栈，栈深的时候会造成运行效率低下。

- 非递归实现：
  - 栈支持压入和弹出；
  - 栈能提高效率。

**算法分析**

DFS是图论中的算法，分析利用DFS解题的复杂度，应当借用图论的思想。邻接表，邻接矩阵。假设图里有V个顶点，E条边。

时间复杂度：

- 邻接表：

  访问所有顶点的时间为O(V),而查询所有顶点的邻居需要O(E),时间复杂度为O(V+E),适合稀疏矩阵。

- 邻接矩阵：

  需要O(V^2);

空间复杂度：

DFS需要堆栈来辅助，最坏情况下，所有的顶点都压入堆栈中，空间复杂度是O(N),即O(M*N);

### 广度优先搜索(BFS)

一般用来解决最短路径问题，和深度优先搜索不一样，从起始点出发，一层一层地进行，每层当中的点距离起始点的步数是相同的，找到目的地之后就可以立即结束。

也可从两端开始，提高搜索的效率。

同样借助图论的分析方法，假设有 V 个顶点，E 条边。

时间复杂度：

- 邻接表

  每个顶点都需要被访问一次，时间复杂度是 O(V)；相连的顶点（也就是每条边）也都要被访问一次，加起来就是 O(E)。因此整体时间复杂度就是 O(V+E)。

- 邻接矩阵

  V 个顶点，每次都要检查每个顶点与其他顶点是否有联系，因此时间复杂度是 O(V2)。

空间复杂度：

需要借助一个队列，所有顶点都要进入队列一次，从队列弹出一次。在最坏的情况下，空间复杂度是 O(V)，即 O(M×N)。