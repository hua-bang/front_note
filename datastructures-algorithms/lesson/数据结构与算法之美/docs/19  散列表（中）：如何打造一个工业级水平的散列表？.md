# 19 | 散列表（中）：如何打造一个工业级水平的散列表？

![img](https://static001.geekbang.org/resource/image/28/5b/28cd69b35b43faba13958ed336db425b.jpg)

散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。

在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。

**如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？**

### 如何设计散列函数？

散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。

#### 原则

- 散列函数的设计不能太复杂。
- 散列函数生成的值尽可能随机并且均匀分布。

##### 实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等。

### 装载因子过大了怎么办？

装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。

- 动态扩容
  - 可行，但数据的存储位置怎么算
  - 例子：下图
    - ![img](https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg)
  - 时间复杂度
    - 最好情况，不需要扩容，最好时间复杂度是 O(1)
    - 最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。
    - 摊还分析法：均摊情况下，时间复杂度接近最好情况，就是 O(1)。
    - 注意：
      - 实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。
      - 当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。

#### 如何避免低效的扩容？

当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。

“一次性”扩容的机制在某些情况下就不合适了。

为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。

当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。

![img](https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg)

均摊分析下来，插入一个数据的时间复杂度是O(1);

### 如何选择冲突解决方法？

1. #### 开放寻址法

   - 优点：
     - 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度
     - 序列化简单
   - 缺点：
     - 删除数据的时候麻烦
     - 所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。
   - 当数据量比较小、装载因子小的时候，适合采用开放寻址法。

2. #### 链表法

   - 优点：
     - 对大装载因子的容忍度更高
     - 散列冲突不会像开放寻址那么频繁
   - 缺点：
     - 内存消耗比较大
     - 节点是零散的，对cpu缓存不友好，执行效率有一定影响。
   - 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

#### 何为一个工业级的散列表？工业级的散列表应该具有哪些特性？

- 支持快速地查询、插入、删除操作；
- 内存占用合理，不能浪费过多的内存空间；
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。

#### 如何实现这样一个散列表呢？

- 设计一个合适的散列函数；
- 定义装载因子阈值，并且设计动态扩容策略；
- 选择合适的散列冲突解决方法