# 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？

#### 排序算法种类太多了。

**常见排序**：冒泡排序，插入排序，选择排序，归并排序，快速排序、计数排序、基数排序、桶排序。

![img](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg)

#### 插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

#### 如何分析一个排序算法

**排序算法的执行效率**

1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 比较次数和交换（或移动）次数

**排序算法的内存消耗**

原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

**排序算法的稳定性**

稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种**排序算法叫作稳定的排序算法**；如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**。

#### 冒泡排序（Bubble Sort）

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩**互换**。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

**例子**：4，5，6，3，2，1

![img](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg)

经过一次冒泡，一个数就在指定位置了，此时我们总共进行6次即可。

![img](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)

实际上，可以优化过程，当某次冒泡没有交换时，说明已经完成有序了。不用再继续执行后续的冒泡操作。

![img](https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg)

#### 冒泡是原地排序算法吗

只涉及相邻数据交换，常量级空间，空间复杂度为O(1),是一个原地排序算法。

#### **冒泡排序是稳定的排序算法吗**

是，当元素相同时，我们并不进行交换操作。

#### 冒泡排序的时间复杂度时多少

最好(完全排好序)是O(n)，最坏(完全倒序)是O(n^2)，平均也是O(n^2)

**有序度、逆序度、满有序度**

逆序度 = 满有序度 - 有序度

![img](https://static001.geekbang.org/resource/image/88/34/8890cbf63ea80455ce82490a23361134.jpg)

### 插入排序(Insert sort)

一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。

![img](https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg)

**插入排序具体是如何借助上面的思想来实现排序的呢**

划分两个区间，**已排序**和**未排序**的区间。

初始化已排序区间只有一个元素，即arr[0];

插入算法的核心思想是取**未排序区间**中的元素，在**已排序区间**中找到合适的**插入位置**将其插入，并保证已排序区间数据一直有序。

![img](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)

插入排序包含两个操作，**元素的比较**和**元素的移动**。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于**逆序度**。

![img](https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg)

#### 第一，插入排序是原地排序算法吗

插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

#### 第二，插入排序是稳定的排序算法吗？

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

#### 第三，插入排序的时间复杂度是多少？

有序时候,O(n)

倒序时候,O(n^2)

平均时间,O(n^2)

### 选择排序（Selection Sort）

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

实质上是找索引。

![img](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

#### 第一，选择排序是原地排序算法吗

是。

#### 第二，时间复杂度为多少

选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)

#### 第三，是稳定的排序算法吗

不是。

#### 为什么插入排序要比冒泡排序更受欢迎呢？

泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 **1** 个。

![img](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)