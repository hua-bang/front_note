# 29 | 堆的应用：如何快速获取到Top 10最热门的搜索关键词？

![img](https://static001.geekbang.org/resource/image/0f/53/0f4151db23d0c388cd79cc7ea2602653.jpg)

#### 假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？

堆这种数据结构几个非常重要的应用：优先级队列、求 Top K 和求中位数。

### 堆的应用一：优先级队列

对比：

- 普通队列：先进先出。

- 优先级队列：按照优先级的顺序出队。

如何实现优先级队列？堆就是一个很好的数据结构。

类似于最大堆

- 插入时候，构造堆。
- 取数据时候，取出栈顶数据。

1. #### 合并有序小文件

   100个文件从小到大，用堆存放会比用数组存放高效。

   - 数组存放每次需要循环遍历整个数组，O(n)
   - 堆存放需要时间复杂度为O(logn)

2. #### 高性能定时器

   实质上是以空间来换取性能。

   一般定时器，我们需要去轮询触发，但这样子会比较消耗性能。

   但如果我们使用优先级队列来存放时，那么我们只要拿到第一个任务，计算时间间隔后，在触发该定时器，并计算下一个任务执行所需要等待的时间。

### 堆的应用二：利用堆求 Top K

分为静态和动态

#### 针对于静态

我们首先维护一个大小为k的最小堆（根据数组生成）,然后再去遍历后面的元素，当大于堆顶元素，将堆顶元素删除，并将元素与插入，注意，要构造最小堆。如果比堆顶元素下，则不做处理。到最后，剩下的就是前K的最大数据。

遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。

#### 针对于动态

针对动态数据求得 Top K 就是实时 Top K。怎么理解呢？我举一个例子。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。

如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)。

实际上，和上面一样，我们仍维护一个K大小的小顶堆。当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。

### 堆的应用三：利用堆求中位数

如何求动态数据集合中的中位数。

使用数组存放，每次计算中位数也可以，但每次都要排序，效率不高。

#### 借助堆这种数据结构，我们不用排序，就可以非常高效地实现求中位数操作。

我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。

也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 2n 个数据存储在大顶堆中，后 2n 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 2n+1 个数据，小顶堆中就存储 2n 个数据。

![img](https://static001.geekbang.org/resource/image/08/99/08c29d3e014a4baf5f8148c2271e6099.jpg?wh=1142*552)

#### 问题，插入的时候如何调整两个堆呢？使得大顶堆的堆顶元素是中位数？

如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。

容易出现，两个堆的数据个数不符合的情况。

这时候，我们可以将堆顶元素移动到另一个堆，当然要考虑情况。

插入的时候，时间复杂度o(logn),查询的时候，O(1);

### 内容小结

我们今天主要讲了堆的几个重要的应用，它们分别是：优先级队列、求 Top K 问题和求中位数问题。优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样罢了。求 Top K 问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高效率地查询 Top K 的数据。求中位数实际上还有很多变形，比如求 99 百分位数据、90 百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。