# 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？

### 归并排序和快速排序

归并排序和快速排序都用到了分治思想，非常巧妙。时间复杂度为O(nlogn)

### 归并排序

- 思想：如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

  ![img](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)

- 归并排序使用的就是分治思想,分而治之。将一个大问题分解成小的子问题来解决。

- **分治是一种解决问题的处理思想，递归是一种编程技巧**

#### 归并排序的性能分析

#### 第一，归并排序是稳定的排序算法吗？

归并排序是一个稳定的排序算法

#### 第二，归并排序的时间复杂度是多少？

T(a) = T(b) + T(c) + K

不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。

归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。

#### 第三，归并排序的空间复杂度是多少？

那就是归并排序不是原地排序算法。在合并过程中需要借助额外的存储空间。

### 快速排序的原理

我们再来看快速排序算法（Quicksort），我们习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。我们待会会讲两者的区别。现在，我们先来看下快排的核心思想。

快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。

我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

![img](https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg)

根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。

```js
quickSort(p,r) = quick_sort(p…q-1) + quick_sort(q+1… r)
终止条件：p >= r
```

不考虑空间消耗的话，就相对简单

![img](https://static001.geekbang.org/resource/image/66/dc/6643bc3cef766f5b3e4526c332c60adc.jpg)

但会有很多的内存浪费，就不是原地排序算法了。

里的处理有点类似选择排序。我们通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。我们每次都从未处理的区间 A[i...r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。

![img](https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg)

快速排序并不是一个稳定的排序算法。

![img](https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg)

可以发现，

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。

快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。

有序的时候可能回变成O(n^2)

我们刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？O(nlogn)