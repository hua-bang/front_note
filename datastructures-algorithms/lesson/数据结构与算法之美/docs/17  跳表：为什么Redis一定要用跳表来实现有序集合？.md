# 17 | 跳表：为什么Redis一定要用跳表来实现有序集合？

对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做**跳表（Skip list）**

跳表这种数据结构对你来说，可能会比较陌生，因为一般的数据结构和算法书籍里都不怎么会讲。但是它确实是一种各方面性能都比较优秀的动态数据结构，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。

Redis 中的有序集合（Sorted Set）就是用跳表来实现的。

### 如何理解“跳表”？

单链表查找，事件复杂度会很高，O(n).

![img](https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg)

每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或索引层。

![img](https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg)

加入索引之后，查找一个结点需要遍历的个数减少了，即提高了查找效率。

那如果我们在加多一层索引呢？

![img](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)

加多几层索引呢？

![img](https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg)

**链表+多级索引，就是跳表。**

#### 时间复杂度

- 根据每个索引包含的个数计算
- 平均是O(logn)

#### 跳表是不是很浪费内存？

那确实，设每个分成m个结点，

则: n/m+n/m^2+n/m^3....+m

平均下来为O(n)

### 高效的动态插入和删除

- 插入

  - 当找到位置进行插入时O(1)

  - 但是查找需要O(logn)

    ![img](https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg)

- 删除

  - 主要要获取前驱结点

### 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

![img](https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg)

我们需要动态维护平衡，使得跳表操作更优。

跳表是通过随机函数来维护前面提到的“平衡性”。

### 小结

跳表是使用空间换时间的设计思路，提高查询的效率。实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速地插入、删除、查找操作，时间复杂度都是 O(logn)。

跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。实现不简单。