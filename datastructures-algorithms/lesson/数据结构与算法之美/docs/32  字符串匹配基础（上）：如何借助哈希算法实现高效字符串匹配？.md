# 32 | 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？

![img](https://static001.geekbang.org/resource/image/b9/66/b997edcd68d6f7393275659f8653a766.jpg)

字符串匹配算法有很多

- BF算法
- RK算法
- BM算法
- KMP算法

注：RK算法是BF算法的改进，它巧妙借助了我们前面讲过的哈希算法，让匹配的效率有了很大的提升。**RK 算法是如何借助哈希算法来实现高效字符串匹配的呢**

### BF算法

Brute Force的缩写。即暴力匹配算法。

概念：

- **主串**：在A中找字符串B，则A为主串。
- **模式串**：在A中找字符串B，则B为模式串。

思想：我们在主串中，检查起点位置分别是0，1，2...n-m且长度为m的n-m+1个子串，看看有没有匹配的。

![img](https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg)

从上述我们可以看出，极端情况下，主串若为"aaaaaaaaaa...aaaa",模式串如果为"aaaaab"。那我们每次都要对比m个字符，要对比n-m+1次，最坏情况时间复杂度为O(n*m);

尽管时间复杂度很高，但在实际开发中，又比较常用。

原因：

- 大部分情况下，模式串和主串的长度都不会太长。且匹配过程中遇到不匹配就停止，不需要全比对。即使最坏时间复杂度为O(n*m)，但是实际上，执行效率会比较高。
- 思想简单，代码实现也简单。KISS（Keep it Simple and Stupid）设计原则。

### RK 算法

RK算法，即BF算法的升级版。

在BF中，我们假设模式串长度为m，主串长度为n，那么在主串中，就有n-m+1个长度为m的字串，我们只需要暴力对比n-m+1子串和模式串，就可以找出主串与模式串匹配的子串。

但是每次检查主串与子串的匹配，需要依次对比字符，故时间复杂度会比较高，O(n*M).此时我们引入哈希算法。

RK算法思路：

1. 通过哈希算法对主串中（n-m+1）个子串分别求哈希值。
2. 逐个对比模式串和子串的哈希值的大小。
3. 若相等，则在对比该字串和模式串（因为可能会发生哈希冲突）。

![img](https://static001.geekbang.org/resource/image/01/ee/015c85a9c2a4adc11236f9a40c6d57ee.jpg)

问题：

- 在计算子串的时候，我们需要遍历子串的每个字符。这也是一个可以优化的点之一如何优化呢？

  - 哈希算法设计需要合理，我们这里就以26进制来表示字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。（参考十进制，如下图）

    ![img](https://static001.geekbang.org/resource/image/d5/04/d5c1cb11d9fc97d0b28513ba7495ab04.jpg)

  - 我们再看下图，发现规律，相邻两个子串的哈希值计算公式有一定关系。

    ![img](https://static001.geekbang.org/resource/image/f9/f5/f99c16f2f899d19935567102c59661f5.jpg)

    ![img](https://static001.geekbang.org/resource/image/c4/9c/c47b092408ebfddfa96268037d53aa9c.jpg)

  - 同时，我们可以先计算26^(m-1)存储表中，之后再查表。

    ![img](https://static001.geekbang.org/resource/image/22/2f/224b899c6e82ec54594e2683acc4552f.jpg)

- RK时间复杂度分析

  - 两个算法部分
    - 计算子串哈希值 O(n)
    - 子串哈希值和模式串哈希值对比 每次O(1), 最多比较(n-m+1)，也为O(n)
    - 故总体上也为O(n)

- 发生哈希冲突怎么办？

  - 影响：不同的子串和模式串可能哈希值一样。
  - 解决：
    - 哈希值相等，再继续对比子串和模式串。
    - 不相等，则不匹配。

- 极端情况下：

  - 即成了大量冲突，导致RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。但也不要太悲观，一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。

### 总结

BK

- 简单，除暴
- 思路：拿模式串与主串中的字串对比。
- 时间复杂度：O(n*m)

RK

- 借用了哈希算法
- 思路：对每个子串求哈希值，并进行比较，减少比较的时间。
- 时间复杂度：
  - 理想情况下：O(n)
  - 极端情况：哈希算法大量冲突:O(n*m)