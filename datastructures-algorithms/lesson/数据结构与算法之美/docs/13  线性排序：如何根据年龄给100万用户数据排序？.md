# 13 | 线性排序：如何根据年龄给100万用户数据排序？

### 线性排序

- 桶排序
- 计数排序
- 基数排序

这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。

### 桶排序(Bucket Sort)

核心思想就是将要排序的数据分到几个有序的桶中，每个桶在单独排序。再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

![img](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg?wh=1142*705)

桶排序的时间复杂度为什么是 O(n) 呢？

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

#### 桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？

不行。实际上，桶排序对要排序数据的要求是非常苛刻的。

首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。

其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

#### 计数排序（counting sort）

计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

将对应数值放入对应的桶中。

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。**

勿死记硬背 理解为主

![img](https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg?wh=1142*1522)

### 基数排序（Radix sort）

思想：根据前几位（或后几位）排序

![img](https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg?wh=1142*511)

这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。

按照每一位来排序，们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。

遇到不等长怎么办，我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。